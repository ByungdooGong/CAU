# 네트워크
## 네트워크 계층 구조
- OSI 7 계층
    ```
    Physical - DataLink - Network - TransPort - Session - Presentation - Application
    ```
- TCP/IP 4계층
    ```
    Network Interface - Internet - (Host to Host)Transport - Application
    ```
- 전송계층(Transport)
    - TCP가 속해있다. 
    - 두 호스트간 연결을 맺고 통신 목적지까지 데이터를 전달하는 기능을 한다. 
    - TCP는 연결지향적
        ```
        오류제어, 흐름제어, 혼잡제어, 타이머재전송 등의 기능을 한다.
        데이터 전송선로(Session)을 만든다.
        데이터의 신뢰도가 중요하다고 판단될 때 사용한다.
        ```
    - UDP는 비연결지향적
        ```
        최소한의 오류제어 기능만 수행한다.
        실시간 멀티미디어 정보를 수행하기 위해 주로 사용한다.
        ```
- OSI 7 계층이란
    - 네트워크에서 통신이 일어나는 과정을 7단계로 나눈 것을 의미한다.
    - 통신이 일어나는 과정을 단계별로 파악할 수 있다. 
        > 1계층 - 물리계층(Physical Layer)

        주로 전기적, 기계적, 기능적인 특성을 이용해서 통신 케이블로 데이터를 전송하게 된다. 통신 단위는 비트이며 0과 1로 나타내어짐.
        단지 데이터를 전달만 할뿐 데이터가 무엇인지, 어떤 에러가 있는지 신경쓰지 않는다. 단지 데이터를 전기적인 신호로 변환해서 주고받는 기능만 한다.
        
        통신케이블, 리피터, 허브 등이 있다.

        > 2계층 - 데이터링크계층(DataLink Layer)

        물리계층을 통해 송수신되는 정보의 오류와 흐름을 관리하여 안전한 정보의 전달을 수행할 수 있도록 도와주는 역할을 한다. 통신에서의 오류를 찾아주고 재전송 하는 기능을 가지고 있다. 
        맥(Mac) 주소를 가지고 통신을 한다. 
        이 계층에서 전송되는 단위를 프레임이라고 한다.
        브리지, 스위치를 통해 맥 주소를 가지고 물리계층에서 받은 정보를 전달한다. 

        데이터링크계층은 포인트 투 포인트간 신뢰성 있는 전송을 보장하기 위한 계층으로 CRC기반의 오류제어와 흐름제어가 필요하다. 주소체계는 계층이 없는 단일구조이다. 가장 잘 알려진 것이 이더넷이다. 

        > 3계층 - 네트워크계층(Network Layer)
        ```
        대표적인 기능 
            - 라우팅(Route) : 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능
            - 흐름제어, 세그멘테이션, 오류제어, 인티네트워크 등
            - 주소부여(IP)
        ```
        계층을 선택하고 주소를 정하고 경로에 따라 패킷을 전달해주는 것이 이 계층의 역할이다. 네트워크계층은 여러개의 노드를 거칠때마다 경로를 찾아주는 역할을 하는 계층으로 다양한 데이터들을 전달하고 그 과정에서 전송계층이 요구하는 서비스 품질(QoS)을 제공하기 위한 기능적, 절차적 수단을 제공한다. 
        데이터를 연결하는 다른 네트워크를 통해 전달함으로써 인터넷이 가능하게 만드는 계층이다. 논리적인 주소구조(IP), 곧 네트워크 관리자가 직접 주소를 할당하는 구조를 가지며, 계층적이다.
- IP 계층
    - TCP/IP 상에서 IP 계층이란 네트워크의 주소 (IP 주소)를 정의하고, IP 패킷의 전달 및 라우팅을 담당하는 계층
    - 종류
        ```
        IP 프로토콜 : 패킷의 전달을 책임
        
        ICMP : 패킷 전달 에러의 보고 및 진단
        
        ARP(Address Resolution Protocol) : 주소를 풀어주는 프로토콜, 네트워크상에서 데이터를 보내기 위해서는 목적지의 MAC주소가 필요한데 IP주소로 MAC주소를 알아내는 프로토콜. 즉 논리주소(IP)->물리주소(MAC)

        RARP(Reverse Address Resolution Protocol) : MAC주소로 IP주소를 알아내는 프로토콜. 잘 안씀.
        ```
    

    

## 3 Way-HandShaking
- TCP가 연결지향적 성격을 갖게 해주는 과정.
- SYN(synchronize sequence number)와 ACK(acknowledgements)

<가정> 
클라이언트 A와 서버 B 가 통신 <br>
```
[step1]
A클라이언트는 B서버에 접속을 요청하는 SYN 패킷을 보낸다. A클라이언트는 SYN을 보내고 SYN/ACK 응답을 기다리는 SYN_SENT 상태가 되는 것.

[step2]
이때 서버는 Listen 상태로 포트 서비스가 가능한 상태여야 한다. B서버는 SYN 요청을 받고 A클라이언트에게 요청을 수락한다는 ACK와 SYN flag가 설정된 패킷을 발송하고 A가 다시 ACK으로 응답하기를 기다린다. B서버는 SYN_RECEIVED 상태가 된다.

[step3]
A클라이언트는 B서버에게 ACK을 보내고 이후로부터는 연결이 이루어지고 데이터가 오가게 되는 것이다. 이때의 B서버 상태가 ESTABLISHED 이다. 
```

## 흐름제어(FLOW Control)
- 송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 기법
- 수신측이 송신측보다 처리가 빠르면 상관없지만 반대의 경우 전송량을 수신측에 따라 제어해야한다.

    > Stop and Wait방식
    - 매번 전송한 패킷에 대해 확인응답을 받아야만 그 다음 패킷을 전송하는 방법.

    > Sliding Window
    - 수신측에서 설정한 윈도우 크기만큼 송신측에서 확인응답 없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 제어 기법.

    - 동작방식
        ```
        먼저 윈도우에 포함되는 모든 패킷을 전송하고, 그 패킷들의 전달이 확인되는대로 이 윈도우를 옆으로 옮김(Slide)으로써 그 다음 패킷들을 전송
        ```
    - 실제 데이터를 보내기전에 TCP-3-way-handshaking을 통해 수신컴퓨터의 window size에 자신의 send window size를 맞추게 된다. 즉 상대방이 받을 수 있는 크기에 맞춰 전송을 하게 된다. 
    - 수신 윈도우보다 작거나 같은 크기로 송신 윈도우를 지정하면 흐름제어 가능. 
    - 수신 측에서 ACK를 전송할 때마다 버퍼의 범위가 한번에 미끄러지듯이 이동.

## 혼잡제어(Congestion Control)
- 한 라우터에 데이터가 몰릴경우 혼잡하다 -> 송신측에서 보내는 데이터의 전송속도를 강제로 줄이는 방법.
- 혼잡제어 알고리즘
    > AIMD(Additive Increase / Multicative Decrease)
    - 처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 window 크기를 1씩 증가시켜가며 전송하는 방법. 
    - 패킷전송에 실패하거나 일정 시간을 넘으면 패킷을 보내는 속도를 절반으로 줄이게 됩니다. 
    - 장점 
        - 나중에 진입하는 쪽이 불리하지만 시간이 흐르면 평형 상태로 수렴하게 되는 특징 있다. 
    - 단점
        - 초기에 네트워크의 높은 대역폭을 사용하지 못하여 오랜시간이 걸리고, 네트워크가 혼잡해지는 것을 미리 감지하지 못함.

    > Slow Start
    - 위와 비슷. 패킷이 문제없이 도착하면 ACK 패킷마다 window size를 1씩 늘려준다. 즉 한 주기가 지나면 window size가 2배가 된다. 
    - 혼잡상태가 발생하면 window size를 1로 떨어뜨린다. 

    > Fast Retransmit(빠른 재전송)
    - 추가된 방식. 먼저 도착해야할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK 패킷을 보내게 된다. 
    - 단 중간에 패킷하나가 손실되게 되면 보내는 측에서 중복된 ACK 패킷을 받게 되고, 이것을 감지하는 순간 문제가 되는 순번의 패킷을 재전송해줄 수 있다. 
    - 중복된 순번의 패킷을 3번 받으며 재전송을 하게 된다. 혼잡을 감지하고 window size를 줄인다.
    
    > Fast Recovery(빠른 회복)
    - 혼잡한 상태가 되면 winodw size를 1로 줄이지 않고 반으로 줄임. 
## Nagle Algorithm
- 네트워크 상에 패킷의 수를 줄이기 위해 개발된 알고리즘
- "가능하면 조금씩 여러번 보내지 말고 한번에 많이 보내라"
    ```
    ACK를 받은 다음에 데이터를 보내고 ACK를 받을 때까지 출력버퍼의 데이터를 저장하였다가 ACK를 받으면 버퍼의 데이터를 모두 패킷으로 만들어 보낸다는 것.

    장점 - 네트워크의 효율성이 높아짐.
    단점 - 송신 호스트가 ACK를 받을 때까지 기다려야 하므로 전송 속도가 느려짐.
    ```


## TCP Connection 

## Subnet Mask


# 데이터 베이스
- 후보키 
    - 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용하는 속성들의 부분집합. 
    - 유일성과 최소성을 만족해야함.
    
- 기본키
    - 후보키 중에서 선택한 주키
    - 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성.
    - null 값을 가질 수 없음. 

- 대체키
    - 후보키 중 기본키를 제외한 나머지

- 슈퍼키
    - 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키
    - 유일성은 만족하지만 최소성은 만족 못한다. 

- 외래키
    - R1과 R2가 관계를 맺고 있을 때 R1의 외래키는 R2의 기본키를 뜻한다.

## 무결성
- 개체 무결성
    -  기본키는 NULL 값이나 중복값을 가질 수 없음.
- 참조 무결성
    - 외래키는 NULL이거나 참조 릴레이션의 기본키와 같아야한다.
- 도메인 무결성
    - 특정 속성의 값이 그 속성이 정의된 도메인에 속한 값이어야한다. 

## 정규화
- 함수적 종속성 등의 종속성 이론을 이용하여 잘못 설계된 관계형 스키마를 더 작은 속성의 세트로 쪼개어 바람직한 스키마로 만들어가는 과정.

- 데이터 구조의 안정성을 최대화 한다.
- 효과적인 검색 알고리즘을 생성할 수 있다. 
- 중복을 배제하여 삽입, 삭제, 갱신 이상의 발생을 방지한다. 

### 정규화 과정
```
비정규 릴레이션 -> 1NF : 도메인이 원자값
1NF -> 2NF : 부분적 함수 종속 제거
2NF -> 3NF : 이행적 함수 종속 제거
3NF -> BCNF : 결정자이면서 후보키가 아닌 것 제거
BCNF -> 4NF : 다치종속 제거
4NF -> 5NF : 조인종속성 이용
```


# 운영체제
- 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임
- 종류
    - Windows, MS-DOS, UNIX, Linux 등
## 운영체제 운용 기법
> 일괄처리 시스템 
- 일정 기간 데이터를 모아 한꺼번에 처리
- 급여 계산, 지불 계산, 연말 결산 등의 업무에 사용

> 다중 프로그래밍 시스템
- 하나의 CPU와 주기억장치를 이용하여 여러개의 프로그램을 동시에 처리하는 방식

> 시분할 시스템
- 여러명의 사용자가 사용하는 시스템에서 컴퓨터가 사용자들의 프로그램을 번갈아가며 처리해 줌으로써 각 사용자에게 독립된 컴퓨터를 사용하는 느낌을 주는 것.
- = Round Robin 방식
- 다중 프로그래밍 방식과 결합하여 모든 작업이 동시에 일어나는 것처럼 대화식 처리가 가능.

> 다중 처리 시스템
- 여러개의 CPU와 하나의 주기억장치를 이용하여 여러 개의 프로그램을 동시에 처리.

> 실시간 처리 시스템
- 데이터 발생 즉시 처리하여 결과를 산출
- 우주선 운행이나 레이더 추적기, 은행 온라인 업무, 좌석 예약 업무 등 시간에 제한을 두고 수행해야 하는 작업에 사용.

> 다중 모드 처리
- 일괄 처리, 시분할, 다중 처리, 실시간 처리를 한 시스템에서 제공

> 분산 처리 시스템
- 여러 개의 컴퓨터(프로세서)를 통신 회선으로 연결하여 하나의 작업을 처리하는 방식.

## 컴파일러와 인터프리터 
- 컴파일러 
    - 고급언어 -> 기계어
    - 소스 프로그램 -> 목적 프로그램
    - 링킹 작업을 통해 컴퓨터에서 실행 가능한 실행 프로그램 생성
    - C++, C, FORTRAN
- 인터 프리터
    - 고급 언어로 작성된 프로그램을 한줄단위로 번역하고 동시에 한줄단위로 실행.
    - 시분할 시스템에 유리
    - 목적프로그램 생성 x
    - BASIC, SNOBOL, LISP 

> 자바에서 컴파일
```
일반 프로그램은 하드웨어를 제어하기 위한 OS가 동작하고, OS 위에서 프로그램이 실행된다. 프로그램을 OS마다 다르게 제작해야했지만 자바 프로그램은 OS위에 JVM이 존재하여 운영체제에 의존적이지 않다. 

자바언어로 된 코드를 JVM이 인식할 수 있는 JVM 명령어 코드(바이트 코드)로 변환.

자바코드(.java) -> 자바 컴파일러 -> 자바 바이트 코드(.class) -> 자바 클래스 로더 -> 애플리케이션 실행
```

## 링커와 로더
> 링커
- 언어 번역 프로그램이 생성한 목적 프로그램들과 라이브러리, 다른 실행 프로그램(로드 모듈) 등을 연결하여 실행 가능한 로드 모듈을 만드는 시스템 소프트웨어. 

> 로더
- 로드 모듈을 디스크 등의 보조기억장치로부터 주기억장치에 적재하는 시스템 소프트웨어.

## 스케줄링 / 문맥 교환
> 스케줄링
- 프로세스가 생성되어 실행될 때 필요한 시스템의 여러 자원을 해당 프로세스에게 할당하는 작업. 

- 종류
    - 비선점 스케줄링(Non-Preemptive)
        ```
        이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법
        종류 : FCFS(FIFO), SJF, 우선순위, HRN, 기한부 등의 알고리즘
        ```
    - 선점 스케줄링(Preemptive)
        ```
        하나의 프로세스가 CPU를 할당받아 실행 하고 있을 때 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법.

        종류 : SRT, 선점 우선순위, RR, 다단계 큐, 다단계 피드백 큐 
        ```
    


> 문맥교환
- 하나의 프로세스에서 다른 프로세스로 CPU가 할당되는 과정에서 발생되는 것. 현재 CPU가 할당된 프로세스의 상태 정보를 저장하고, 새로운 프로세스의 상태 정보를 설정한  후 CPU를 할당하여 실행되도록 하는 작업.


### 비선점 스케줄링
> FCFS(First Come First Service)
- 준비상태 큐에 도착한 순서대로 차례로 CPU를 할당하는 기법.

> SJF(Shortest Job First)
- 실행 시간이 가장 짧은 프로세스에 먼저 CPU를 할당하는 기법. 
- 가장 적은 평균 대기 시간을 제공하는 최적 알고리즘.

> HRN(Hightest Response ratio Next)
- 실행 시간이 긴 프로세스에 불리한 SJF 보완.
- 우선순위 = (대기시간 + 서비스시간)/서비스시간

> 기한부(Deadline)
- 프로세스에 일정한 시간을 주어 그 시간 안에 프로세스를 완료하는 기법.

> 우선순위(Prioriy)
- 준비상태 큐에서 기다리는 각 프로세스마다 우선순위를 부여하여 가장 높은 프로세스에게 먼저 CPU를 할당하는 기법

*에이징 기법*
- 시스템에서 우선순위가 낮아 무한정 기다릴 경우, 한번 양보하거나 기다린 시간에 비례하여 일정 시간이 지나면 우선순위를 한 단계씩 높여 가까운 시간 안에 자원을 할당받도록 하는 기법.

### 선점 스케줄링
> 선점 우선순위
- 준비상태 큐의 프로세스 중에서 우선순위가 가장 높은 프로세스에 먼저 CPU를 할당하는 방식. 

> SRT(Shortest Remaining Time)
- SJF를 선점 형태로 변경한 기법. 

> RR(Round Robin)
- 시분할 시스템을 위해 고안된 방식, FCFS를 선점 형태로 변경한 기법.
- FCFS 기법과 같이 준비상태 큐에 먼저 들어온 프로세스가 먼저 CPU를 할당받지만 각 프로세스는 할당된 시간동안만 실행한 후 실행이 완료되지 않으면 다음 프로세스에 CPU를 넘겨주고 준비상태 큐 가장 뒤로 배치.
- 할당되는 시간이 클 경우 FCFS와 같지만, 할당되는 시간이 작을 수록 문맥교환 및 오버헤드가 많이 일어난다. 

> 다단계 큐
- 프로세스를 특정 그룹으로 분류 할 수 있을 경우 그룹에 따라 각기 다른 준비상태 큐를 사용하는 기법.

> 다단계 피드백 큐
- 특정 그룹의 준비상태 큐에 들어간 프로세스가 다른 준비상태 큐로 이동할 수 없는 다단계 큐를 준비상태 큐 사이로 이동할 수 있도록 개선한 방법.

## 교착상태(Deadlock) 
- 상호 배제에 의해 나타나는 문제점으로, 둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상.

- 필요충분조건
    - 상호 배제(Mutual Exclusion)
        - 한 번에 한 개의 프로세스만이 공유 자원을 사용할 수 있어야 함.
    - 점유와 대기(Hold & Wait)
        - 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용되고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 함.
    - 비선점(Non-preemptive)
        - 다른 프로세스에 할당된 자원은 사용이 끝날 때 까지 강제로 빼앗을 수 없어야 함.
    - 환형 대기(Circular Wait)
        - 공유 자원과 공유 자원을 사용하기 위해 대기하는 프로세스들이 원형으로 구성되어 있어 자신에게 할당된 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구해야 함.

- 해결방법
    - 예방 기법
        - 교착상태 발생의 4가지 조건 중 어느 하나를 제거(부정)함으로써 수행되며 일반적으로 자원의 낭비가 가장 심함.
        - 상호 배제 부정, 점유 및 대기 부정, 비선점 부정, 환형 대기 부정
    - 회피 기법
        - 교착 상태가 발생할 가능성을 배제하지 않고, 교착 상태가 발생하면 적절히 피해나가는 방법
        - 은행원 알고리즘
            ```
            Dijkstra가 제안한 것으로, 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는 데서 유래한 기법

            각 프로세스에게 자원을 할당하여 교착상태가 발생하지 않으며 모든 프로세스가 완료될 수 있는 상태를 안전 상태, 교착 상태가 발생할 수 있는 상태를 불안전 상태라고 함.
            ```
    - 발견 기법
        - 시스템이 교착 상태가 발생했는지 점검하여 교착 상태에 있는 프로세스와 자원을 발견하는 것으로, 자원 할당 그래프 등을 사용함.
    - 회복 기법
        - 교착 상태를 일으킨 프로세스를 종료하거나 교착 상태의 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복하는 것.

## Paging


## CPU 클럭


## 패리티비트